# 이더리움 백서
- https://ethereum.org/ko/whitepaper/
    - 이더리움 계정, 메시지와 거래, 메시지, 이더리움의 상태전환 함수, 코드 실행
- 차세대 '스마트 컨트랙트'와 탈중앙화 된 '어플리케이션' 플랫폼
- 이더리움을 만든사람? 비탈릭 부테린
- 비트코인이 많이 언급됨 (비트코인의 보안에 조금 더 신경 쓴 느낌)

## 비트코인과 다른점
- 비트코인 : 결제에 포커싱
- 이더리움 : 탈중앙화한 어플리케이션을 제안

## 블록체인 기술을 사용한 대안적인 어플리케이션
- 컬러드 코인 : 사용자 정의 화폐와 금융 상품을 블록체인 위로 표현
- 스마트 자산 : 물리적 대상의 소유권을 표현
- 네임 코인 : 도메인 이름과 같은 비동질적 자산을 기록
<br><br>
- 임의적인 계약의 규칙을 구현한 코드에 의해 디지털 자산을 더 편리하게 관리할 수 있도록 스마트 컨트랙트, 더 나아가 블록체인을 기반으로 한 자율조직 DAO 등을 만듦
- 이더리움은 완벽한 튜링 완전 프로그래밍 언어가 심어진 블록체인
    - 튜링 완전 : 계산 가능한 문제를 해결할 수 있는 모든 기계의 공통된 능력
- 프로그래밍 언어를 통해 코딩된 규칙에 따라 어떤 상태를 다르게 변환시키는 기능이 포함된 계약을 만듦
- 유저들이 설명한 시스템을 직접 구현 가능하게 작성할 수 있음

## 역사
- 과거에 비트코인과 유사한 암호화폐를 만드려는 시도가 있었으나, 중앙화 된 데이터에 의존을 하고 있었기 때문에 조명 받지 못함
- 탈중앙화 개념도 꾸준히 제안되었으나 번번히 실패함
- 사카시 나카모토가 합의 알고리즘(POW)의 사용으로 탈중앙화를 실현시킴
- 비탈릭 부테린은 작업증명의 2가지 문제를 동시에 해결
    - 아주 간단하지만 효과가 좋은 합의 알고리즘(POS) 제공
    - 컴퓨팅 파워가 올라가면서 마이너들이 그룹을 이루어 채굴하고 보상을 나눔 -> 중앙화 되는 것 아니냐? -> 지분 증명(POS)이라는 새로운 합의 알고리즘 등장 -> 누구나 합의 프로세스에 참여할 수 있음
        - POW : 각 노드가 가진 계산 능력을 통해 nonce를 증가시켜 hash를 찾음
        - POS : 화폐 보유량에 따라 각 노드의 결정된 정도를 계산

## 상태 변환 시스템으로서의 비트코인
- 비트코인의 트랜잭션 == 이더리움의 상태변환 시스템
- 상태란?
    - 쇼핑몰에서 상품의 현재 상태를 나타낼 테이블을 하나 생성
    - 테이블에 주문이라는 상태가 있다고 가정했을 때 내용이 계속 변환 : 주문접수 -> 결제확인 -> 상품준비 -> 상품발송 -> 배송완료 -> 상품수령

## 스크립팅
- 비트코인에는 정말 낮은 수준의 스마트 컨트랜트 존재
- 비트코인의 UTXO는 공개키만으로 해당 계정의 잔액을 조회할 수 있음 (단순 스택 기반)
- 비트코인에서 2, 3개의 개인키를 가지고 서명을 만들어서 검증할 수 있도록 간단한 스크립팅 작성할 수 있지만, 어렵고 실용성이 없어서 실제 사용한 플랫폼 없음
- 이더리움은 서명에 관련된 로직을 스마트 컨트랙트라는 시점으로 바라봄
- 스크립팅의 문제점
    - 튜링 불완전성
    - 무가치
    - 다양한 상태를 표현할 수 없음
    - 블록체인 해독 불가능

## 이더리움의 목적성
- 분산 어플리케이션 제작을 위한 대체 프로토콜(규칙)
- 비트코인으로는 예금, 보험 및 금융상품에 대한 것 구현 불가능 (이자 구현 X)
- 사이트 및 게임에 적용하기 어려움 (상품, 게임 아이템 매칭 등)
- 이더리움은 이 부분을 보완하여 플랫폼을 만듦
- 적은 시간으로 탈중앙화를 사용해서 데이터를 저장하는 사이트, 게임 등을 만듦 (DApp)
- 탈중앙화, 통신할 수 있는 프로토콜을 유저가 쉽게 구현할 수 있도록 도와줌
- 탈중앙화에 데이터를 저장할 수 있다 === 스마트 컨트랙트
- 비트코인의 UTXO처럼 형식적인 데이터가 아닌, 상태 변화를 시켜서 다양한 데이터를 저장하고 사용할 수 있도록 트랜잭션의 구조를 완전히 바꾼 것

## 이더리움 어카운트
- 이더리움에서 상태(state)는 account라고 하는 객체로 구성되어 있음
- 비트코인 : 개인키 생성 -> 개인키로 공개키 생성 -> 12byte 잘라서 account 생성
```javascript
interface Account {
    nonce : number // 트랜잭션 횟수 (이중지불 방지하는 카운터)
    balance : string // 이더리움 화폐(이더)
    storageRoot : string // account의 상태 저장 공간 (초기에는 비어있음)
    codeHash : string // 스마트 컨트랙트 계약의 코드
}
```
- 이더리움 네트워크에서 트랜잭션을 발생 시킬 때 이더(지불하는 수수료)가 없으면 코드 실행 X, 데이터 저장 X
<br><br>
- EOA : 프라이빗 키에 의해 통제되는 외부 소유 어카운트
    - 비트코인의 지갑 개념
    - 다른 어카운트와 이더를 주고받을 수 있음
    - 개인키를 가지고 서명을 해서 트랜잭션(메시지)을 생성
        ```javascript
        interface Account {
            nonce : number 
            balance : string
            storageRoot : string // 사용X
            codeHash : string // 사용X
        }
        ```
- CA : 컨트랙트 코드에 의해 통제되는 컨트랙트 어카운트
    - Account 객체 구조 안의 모든 속성 사용
        ```javascript
        interface Account {
            nonce : number 
            balance : string
            storageRoot : string // 사용O (value라는 상태 변수를 키와 값의 형태로 데이터 저장)
            codeHash : string // 사용O (코드를 컴파일해서 결과 저장)
        }
        ```
    - 개인키 없음 (메시지를 발생시킬 수 없음)
    - 메시지를 받으면 CA가 자신의 코드를 활성화 -> 메시지를 읽어서(실행해서) 상태 변수 변환 or 메시지를 읽고(실행하고) CA에서 다른 CA로 메시지 보냄


## 솔리디티로 스마트 컨트랙트 작성
```javascript
pragma solidity ^0.8.0

contract testContract {
    uint256 value; // 상태 변수 선언
    function setValue(uint256 newValue) public {
        value = newValue; // 상태 변수를 변환 (가스비 지불 O)
    }
    function getValue() public view returns (uint256) {
        return value; // 상태 변수를 조회 (가스비 지불 X)
    }
}
```

## 메시지와 트랜잭션
- 이더리움에서 서명이 있는 영수증 == 트랜잭션
- 서명이 없는 영수증 == 메시지
```javascript
interface Message {
    from : string; // 메시지를 보내는 어카운트(컨트랙트의 주소)
    to : string; // 메시지를 받는 어카운트
    gas : number; // 메시지를 처리하기 위해 사용할 가스의 양
    gasPrice : number; // 가스당 가격
    value : number; // 메시지와 함께 전송할 이더의 양
    data : string; // 메시지 데이터
    nonce : number; // 메시지 송신자의 nonce값 (카운트)
}

interface Transaction extends Message {
    v : number; // 서명 v
    r : string; // 서명 r
    s : string; // 서명 s
}
```